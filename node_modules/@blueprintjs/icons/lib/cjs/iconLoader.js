"use strict";
/*
 * Copyright 2021 Palantir Technologies, Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Icons = void 0;
const iconNames_1 = require("./iconNames");
const iconTypes_1 = require("./iconTypes");
const loaderUtils_1 = require("./loaderUtils");
async function getLoaderFn(options) {
    const { loader = singleton.defaultLoader } = options;
    if (typeof loader === "function") {
        return loader;
    }
    else if (loader === "all") {
        return (await Promise.resolve().then(() => __importStar(require(
        /* webpackChunkName: "blueprint-icons-all-paths-loader" */
        "./paths-loaders/allPathsLoader")))).allPathsLoader;
    }
    else {
        return (await Promise.resolve().then(() => __importStar(require(
        /* webpackChunkName: "blueprint-icons-split-paths-by-size-loader" */
        "./paths-loaders/splitPathsBySizeLoader")))).splitPathsBySizeLoader;
    }
}
/**
 * Blueprint icons loader.
 */
class Icons {
    constructor() {
        /** @internal */
        this.defaultLoader = "split-by-size";
        /** @internal */
        this.loadedIconPaths16 = new Map();
        /** @internal */
        this.loadedIconPaths20 = new Map();
    }
    /**
     * Set global icon loading options for all subsequent `Icons.load()` calls.
     */
    static setLoaderOptions(options) {
        if (options.loader !== undefined) {
            singleton.defaultLoader = options.loader;
        }
    }
    static async load(icons, size, options) {
        if (!Array.isArray(icons)) {
            icons = [icons];
        }
        await Promise.all(icons.map(icon => this.loadImpl(icon, size, options)));
        return;
    }
    /**
     * Load all available icons for use in Blueprint components.
     */
    static async loadAll(options) {
        const allIcons = Object.values(iconNames_1.IconNames);
        (0, loaderUtils_1.wrapWithTimer)(`[Blueprint] loading all icons`, async () => {
            await Promise.all([
                this.load(allIcons, iconTypes_1.IconSize.STANDARD, options),
                this.load(allIcons, iconTypes_1.IconSize.LARGE, options),
            ]);
        });
    }
    /**
     * Get the icon SVG paths. Returns `undefined` if the icon has not been loaded yet.
     */
    static getPaths(icon, size) {
        if (!this.isValidIconName(icon)) {
            // don't warn, since this.load() will have warned already
            return undefined;
        }
        const loadedIcons = size < iconTypes_1.IconSize.LARGE ? singleton.loadedIconPaths16 : singleton.loadedIconPaths20;
        return loadedIcons.get(icon);
    }
    static async loadImpl(icon, size, options = {}) {
        if (!this.isValidIconName(icon)) {
            console.error(`[Blueprint] Unknown icon '${icon}'`);
            return;
        }
        const loadedIcons = size < iconTypes_1.IconSize.LARGE ? singleton.loadedIconPaths16 : singleton.loadedIconPaths20;
        if (loadedIcons.has(icon)) {
            // already loaded, no-op
            return;
        }
        const loaderFn = await getLoaderFn(options);
        try {
            const supportedSize = size < iconTypes_1.IconSize.LARGE ? iconTypes_1.IconSize.STANDARD : iconTypes_1.IconSize.LARGE;
            const paths = await loaderFn(icon, supportedSize);
            loadedIcons.set(icon, paths);
        }
        catch (e) {
            console.error(`[Blueprint] Unable to load ${size}px icon '${icon}'`, e);
        }
    }
    /**
     * @returns true if the given string is a valid {@link IconName}
     */
    static isValidIconName(iconName) {
        return iconNames_1.IconNamesSet.has(iconName);
    }
}
exports.Icons = Icons;
const singleton = new Icons();
//# sourceMappingURL=iconLoader.js.map